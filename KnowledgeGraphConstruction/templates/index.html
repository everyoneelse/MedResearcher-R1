<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŸ¥è¯†å›¾è°±æ„å»ºç³»ç»Ÿ</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            color: #1e293b;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }
        
        .header {
            background: #ffffff;
            padding: 32px 40px;
            border-radius: 24px;
            margin-bottom: 24px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 8px 32px rgba(0, 0, 0, 0.03);
            border: 1px solid #e2e8f0;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: #0f172a;
            letter-spacing: -0.025em;
        }
        
        .header p {
            color: #64748b;
            font-size: 1.1rem;
            font-weight: 400;
        }
        
        .controls {
            background: #ffffff;
            padding: 32px;
            border-radius: 20px;
            margin-bottom: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 24px;
            flex-wrap: wrap;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 8px 32px rgba(0, 0, 0, 0.03);
            border: 1px solid #e2e8f0;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .input-group label {
            font-weight: 500;
            color: #374151;
            font-size: 14px;
            letter-spacing: 0.025em;
        }
        
        .input-group input {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s ease;
            background: #ffffff;
            min-width: 180px;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 0.025em;
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-danger {
            background: #ef4444;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 24px;
            height: 700px;
        }
        
        .panel {
            background: #ffffff;
            border-radius: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 8px 32px rgba(0, 0, 0, 0.03);
            border: 1px solid #e2e8f0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            color: #1e293b;
            padding: 24px 32px;
            font-weight: 600;
            font-size: 16px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .panel-header::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #3b82f6;
            border-radius: 50%;
        }
        
        .panel-content {
            flex: 1;
            padding: 24px 32px;
            overflow: auto;
        }
        
        .progress-container {
            margin-top: 20px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 16px;
            border: 1px solid #e2e8f0;
        }
        
        .progress-bar {
            height: 8px;
            background: #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            transition: width 0.3s ease;
            width: 0%;
            border-radius: 8px;
            position: relative;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .status-text {
            margin-top: 12px;
            font-size: 14px;
            color: #64748b;
            font-weight: 500;
        }
        
        #graph-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #fafbfc;
            border-radius: 16px;
            border: 2px dashed #e2e8f0;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        #graph-container.has-content {
            border-color: #3b82f6;
            border-style: solid;
            background: #ffffff;
        }

        #graph-container svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph-container svg:active {
            cursor: grabbing;
        }

        .graph-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .link {
            stroke: #94a3b8;
            stroke-width: 2;
            fill: none;
            opacity: 0.7;
            transition: all 0.2s ease;
        }

        .link:hover {
            stroke: #3b82f6;
            stroke-width: 3;
            opacity: 1;
        }

        /* æ—§çš„nodeæ ·å¼å·²ç§»åŠ¨åˆ°åé¢ç»Ÿä¸€å®šä¹‰ */

        .node-label {
            font-size: 12px;
            font-weight: 500;
            text-anchor: middle;
            fill: #374151;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(255, 255, 255, 0.8);
        }

        .link-label {
            font-size: 10px;
            font-weight: 400;
            text-anchor: middle;
            fill: #6b7280;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .arrowhead {
            fill: #94a3b8;
            transition: fill 0.2s ease;
        }

        .link:hover + .arrowhead {
            fill: #3b82f6;
        }

        .graph-info {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            color: #6b7280;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* ç©ºçŠ¶æ€æ ·å¼ */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #94a3b8;
            font-size: 14px;
            font-weight: 500;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* åŠ è½½çŠ¶æ€æ ·å¼ */
        .loading-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #6b7280;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e5e7eb;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* QAç»“æœæ ·å¼ */
        #qa-result-container {
            margin: 20px 0;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }
        
        .qa-result-header {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .qa-result-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-small:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .qa-result-content {
            padding: 20px;
        }
        
        .qa-question, .qa-answer {
            margin-bottom: 20px;
        }
        
        .qa-label {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .qa-text {
            background: white;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            line-height: 1.6;
            font-size: 14px;
            color: #4b5563;
        }
        
        .qa-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .qa-meta-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .qa-meta-label {
            font-weight: 500;
            color: #6b7280;
            font-size: 12px;
        }
        
        .qa-meta-item span:last-child {
            background: #dbeafe;
            color: #3b82f6;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .qa-reasoning {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #e5e7eb;
        }
        
        .qa-result-content.collapsed {
            display: none;
        }
        
        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.6;
        }
        
        .empty-state h3 {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #6b7280;
        }
        
        .empty-state p {
            font-size: 14px;
            color: #9ca3af;
        }
        
        .log-entry {
            background: #f8fafc;
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #3b82f6;
            font-size: 13px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            line-height: 1.5;
            transition: all 0.2s ease;
        }
        
        .log-entry:hover {
            background: #f1f5f9;
        }
        
        .log-entry .timestamp {
            color: #64748b;
            font-weight: 500;
        }
        
        .log-entry .level {
            color: #3b82f6;
            font-weight: 600;
            margin: 0 8px;
        }
        
        .log-entry .message {
            color: #1e293b;
        }
        
        .log-entry.error {
            border-left-color: #ef4444;
            background: #fef2f2;
        }
        
        .log-entry.error .level {
            color: #ef4444;
        }
        
        .log-entry.success {
            border-left-color: #10b981;
            background: #f0fdf4;
        }
        
        .log-entry.success .level {
            color: #10b981;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .stat-card {
            background: #f8fafc;
            padding: 20px;
            border-radius: 16px;
            text-align: center;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }
        
        .stat-card:hover {
            background: #f1f5f9;
            transform: translateY(-1px);
        }
        
        .stat-card .number {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 4px;
        }
        
        .stat-card .label {
            font-size: 12px;
            color: #64748b;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* èŠ‚ç‚¹æ ·å¼å·²åœ¨ä¸‹æ–¹ç»Ÿä¸€å®šä¹‰ */
        
        /* åˆ é™¤äº†é‡å¤çš„.node:hoverå®šä¹‰ */
        
        .link {
            stroke: #94a3b8;
            stroke-width: 2;
            stroke-opacity: 0.7;
            transition: all 0.2s ease;
        }
        
        .link:hover {
            stroke-opacity: 1;
            stroke-width: 3;
        }
        
        .node-label {
            font-family: inherit;
            font-size: 11px;
            font-weight: 500;
            fill: #1e293b;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .link-label {
            font-family: inherit;
            font-size: 10px;
            font-weight: 400;
            fill: #64748b;
            text-anchor: middle;
            pointer-events: none;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
                height: auto;
            }
            
            .panel:last-child {
                height: 400px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }
            
            .controls {
                flex-direction: column;
                gap: 16px;
            }
            
            .input-group input {
                min-width: 100%;
            }
            
            .main-content {
                gap: 16px;
            }
            
            .panel-content {
                padding: 16px 20px;
            }
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* åŠ è½½åŠ¨ç”» */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(8px);
        }
        
        .tooltip.show {
            opacity: 1;
        }
        
        /* èŠ‚ç‚¹æ‹–æ‹½çŠ¶æ€ */
        .node.dragging {
            stroke: #ef4444 !important;
            stroke-width: 4px !important;
        }
        
        /* èŠ‚ç‚¹æ ·å¼ç»Ÿä¸€å®šä¹‰ */
        .node {
            stroke: #ffffff;
            stroke-width: 2;
            cursor: pointer;
            transition: stroke 0.2s ease, stroke-width 0.2s ease;
        }
        
        .node:hover {
            stroke: #3b82f6 !important;
            stroke-width: 3px !important;
        }
        
        /* é‡‡æ ·èŠ‚ç‚¹ï¼ˆæ˜Ÿåº§å›¾ï¼‰æ ·å¼ */
        .node.sampled {
            fill: #3b82f6 !important;
            stroke: #1d4ed8 !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.6));
        }
        
        /* é‡‡æ ·è¿çº¿æ ·å¼ */
        .link.sampled {
            stroke: #3b82f6 !important;
            stroke-width: 3px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 4px rgba(59, 130, 246, 0.4));
        }
        
        /* å·¥å…·æç¤ºæ ·å¼ */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        #tooltip.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>çŸ¥è¯†å›¾è°±æ„å»ºç³»ç»Ÿ</h1>
            <p>AIé©±åŠ¨çš„æ™ºèƒ½çŸ¥è¯†å›¾è°±ç”Ÿæˆä¸é—®ç­”æ•°æ®æ„å»ºå¹³å°</p>
        </div>
        
        <div class="controls">
            <div class="input-group">
                <label for="initial-entity">åˆå§‹å®ä½“</label>
                <input type="text" id="initial-entity" placeholder="ä¾‹å¦‚ï¼šé‡å­è®¡ç®—æœº" value="é‡å­è®¡ç®—æœº">
            </div>
            <div class="input-group">
                <label for="max-nodes">æœ€å¤§èŠ‚ç‚¹æ•°</label>
                <input type="number" id="max-nodes" value="30" min="10" max="100">
            </div>
            <div class="input-group">
                <label for="sample-size">é‡‡æ ·å¤§å°</label>
                <input type="number" id="sample-size" value="8" min="3" max="20">
            </div>
            <button id="start-btn" class="btn btn-primary">
                <span class="btn-text">å¼€å§‹æ„å»º</span>
            </button>
            <button id="stop-btn" class="btn btn-danger" style="display: none;">
                åœæ­¢æ„å»º
            </button>
        </div>
        
        <div class="main-content">
            <div class="panel">
                <div class="panel-header">
                    çŸ¥è¯†å›¾è°±å¯è§†åŒ–
                </div>
                <div class="panel-content" style="padding: 0;">
                    <div id="graph-container">
                        <div class="empty-state">
                            <div class="icon">ğŸŒ</div>
                            <h3>å‡†å¤‡æ„å»ºçŸ¥è¯†å›¾è°±</h3>
                            <p>ç‚¹å‡»"å¼€å§‹æ„å»º"æŒ‰é’®æ¥ç”ŸæˆçŸ¥è¯†å›¾è°±</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    æ„å»ºè¿›åº¦ä¸æ—¥å¿—
                </div>
                <div class="panel-content">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="number" id="nodes-count">0</div>
                            <div class="label">èŠ‚ç‚¹æ•°é‡</div>
                        </div>
                        <div class="stat-card">
                            <div class="number" id="edges-count">0</div>
                            <div class="label">å…³ç³»æ•°é‡</div>
                        </div>
                    </div>
                    
                    <div id="progress-info" style="display: none;">
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progress-fill"></div>
                            </div>
                            <div class="status-text" id="status-text">å‡†å¤‡å¼€å§‹...</div>
                        </div>
                    </div>
                    
                    <!-- QAç»“æœæ˜¾ç¤ºåŒºåŸŸ -->
                    <div id="qa-result-container" style="display: none;">
                        <div class="qa-result-header">
                            <h3>ğŸ¯ ç”Ÿæˆçš„QAé—®ç­”å¯¹</h3>
                            <button id="toggle-qa-btn" class="btn btn-small">æŠ˜å </button>
                        </div>
                        <div class="qa-result-content" id="qa-result-content">
                            <div class="qa-question">
                                <div class="qa-label">â“ é—®é¢˜</div>
                                <div class="qa-text" id="qa-question-text"></div>
                            </div>
                            <div class="qa-answer">
                                <div class="qa-label">âœ… ç­”æ¡ˆ</div>
                                <div class="qa-text" id="qa-answer-text"></div>
                            </div>
                            <div class="qa-meta">
                                <div class="qa-meta-item">
                                    <span class="qa-meta-label">ç±»å‹:</span>
                                    <span id="qa-type"></span>
                                </div>
                                <div class="qa-meta-item">
                                    <span class="qa-meta-label">å¤æ‚åº¦:</span>
                                    <span id="qa-complexity"></span>
                                </div>
                                <div class="qa-reasoning" id="qa-reasoning" style="display: none;">
                                    <div class="qa-label">æ¨ç†è¿‡ç¨‹</div>
                                    <div class="qa-text" id="qa-reasoning-text"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="logs-container">
                        <div class="log-entry">
                            <span class="timestamp">ç­‰å¾…ä¸­</span>
                            <span class="level">INFO</span>
                            <span class="message">ç³»ç»Ÿå·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹æ„å»ºçŸ¥è¯†å›¾è°±</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Socket.IO è¿æ¥
        const socket = io();
        
        // DOM å…ƒç´ 
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const initialEntity = document.getElementById('initial-entity');
        const maxNodes = document.getElementById('max-nodes');
        const sampleSize = document.getElementById('sample-size');
        const progressInfo = document.getElementById('progress-info');
        const progressFill = document.getElementById('progress-fill');
        const statusText = document.getElementById('status-text');
        const logsContainer = document.getElementById('logs-container');
        const nodesCount = document.getElementById('nodes-count');
        const edgesCount = document.getElementById('edges-count');
        const graphContainer = document.getElementById('graph-container');
        const btnText = startBtn.querySelector('.btn-text');
        
        // çŠ¶æ€ç®¡ç†
        let isBuilding = false;
        let svg = null;
        let g = null;
        let simulation = null;
        let zoom = null;
        let width = 0;
        let height = 0;
        
        // åˆå§‹åŒ–å›¾è¡¨
        function initGraph() {
            const containerRect = graphContainer.getBoundingClientRect();
            width = containerRect.width;
            height = containerRect.height;
            
            // æ¸…é™¤ç°æœ‰å†…å®¹
            graphContainer.innerHTML = '';
            
            // æ·»åŠ æ§åˆ¶æŒ‰é’®
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'graph-controls';
            controlsDiv.innerHTML = `
                <button class="control-btn" onclick="zoomIn()" title="æ”¾å¤§">+</button>
                <button class="control-btn" onclick="zoomOut()" title="ç¼©å°">-</button>
                <button class="control-btn" onclick="resetZoom()" title="é‡ç½®è§†å›¾">âŒ‚</button>
                <button class="control-btn" onclick="fitToView()" title="é€‚åº”è§†å›¾">âŠ¡</button>
                <button class="control-btn" onclick="redistributeNodes()" title="é‡æ–°åˆ†å¸ƒèŠ‚ç‚¹">âŸ²</button>
                <button class="control-btn" onclick="testGraph()" title="æµ‹è¯•å›¾è¡¨">æµ‹è¯•</button>
            `;
            graphContainer.appendChild(controlsDiv);
            
            // æ·»åŠ å›¾è°±ä¿¡æ¯
            const infoDiv = document.createElement('div');
            infoDiv.className = 'graph-info';
            infoDiv.innerHTML = `
                <div>æ‹–æ‹½ç”»å¸ƒï¼šå¹³ç§»è§†å›¾ | æ»šè½®ï¼šç¼©æ”¾ | æ‹–æ‹½èŠ‚ç‚¹ï¼šè°ƒæ•´ä½ç½®</div>
            `;
            graphContainer.appendChild(infoDiv);
            
            // åˆ›å»ºSVG
            svg = d3.select('#graph-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // æ·»åŠ ç¼©æ”¾è¡Œä¸º
            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // åˆ›å»ºä¸»ç»˜å›¾ç»„
            g = svg.append('g');
            
            // æ·»åŠ å®šä¹‰å…ƒç´ ç”¨äºç®­å¤´å’Œæ¸å˜
            const defs = svg.append('defs');
            
            // ç®­å¤´æ ‡è®°
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 28)
                .attr('refY', 0)
                .attr('markerWidth', 8)
                .attr('markerHeight', 8)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('class', 'arrowhead');
            
            // æ¸å˜å®šä¹‰
            const gradient = defs.append('linearGradient')
                .attr('id', 'nodeGradient')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '100%')
                .attr('y2', '100%');
            
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#ffffff')
                .attr('stop-opacity', 0.3);
            
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#000000')
                .attr('stop-opacity', 0.1);
            
            // åˆå§‹åŒ–åŠ›å¯¼å‘å›¾ - å¼ºåŒ–èŠ‚ç‚¹åˆ†æ•£æ•ˆæœ
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(100).strength(0.3))
                .force('charge', d3.forceManyBody().strength(-2000).distanceMax(600))
                .force('center', d3.forceCenter(width / 2, height / 2).strength(0.1))
                .force('collision', d3.forceCollide().radius(50).strength(1.0))
                .force('x', d3.forceX(width / 2).strength(0.02))
                .force('y', d3.forceY(height / 2).strength(0.02))
                .alphaDecay(0.003)
                .velocityDecay(0.6);
        }
        
        // åˆ›å»ºå¸¦æœ‰æ­£ç¡®ä½ç½®çš„èŠ‚ç‚¹
        function createPositionedNode(id, name, type, index, totalNodes) {
            const centerX = width / 2;
            const centerY = height / 2;
            
            let x, y;
            if (totalNodes <= 1) {
                x = centerX;
                y = centerY;
            } else if (totalNodes <= 6) {
                // å°‘é‡èŠ‚ç‚¹æ—¶ä½¿ç”¨åœ†å½¢åˆ†å¸ƒ
                const angle = (index / totalNodes) * 2 * Math.PI;
                const radius = Math.min(width, height) * 0.2;
                x = centerX + Math.cos(angle) * radius;
                y = centerY + Math.sin(angle) * radius;
            } else {
                // å¤šèŠ‚ç‚¹æ—¶ä½¿ç”¨ç½‘æ ¼+éšæœºåˆ†å¸ƒ
                const cols = Math.ceil(Math.sqrt(totalNodes));
                const rows = Math.ceil(totalNodes / cols);
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                const spacingX = (width * 0.8) / Math.max(cols - 1, 1);
                const spacingY = (height * 0.8) / Math.max(rows - 1, 1);
                
                x = (width * 0.1) + col * spacingX + (Math.random() - 0.5) * 40;
                y = (height * 0.1) + row * spacingY + (Math.random() - 0.5) * 40;
            }
            
            return {
                id: id,
                name: name,
                type: type,
                x: Math.max(50, Math.min(width - 50, x)),
                y: Math.max(50, Math.min(height - 50, y))
            };
        }

        // å¢é‡æ›´æ–°å›¾è¡¨
        let currentGraphData = {nodes: [], links: []};
        
        function updateGraph(data, isIncremental = true) {
            if (!svg || !simulation) {
                initGraph();
            }
            
            const nodes = data.nodes || [];
            const links = data.links || [];
            
            // éªŒè¯è¾“å…¥æ•°æ®
            console.log('åŸå§‹æ•°æ®:', {nodes, links});
            if (!Array.isArray(nodes) || !Array.isArray(links)) {
                console.error('Invalid data format: nodes and links must be arrays');
                return;
            }
            
            if (nodes.length === 0) {
                showEmptyState();
                return;
            }
            
            // å¦‚æœæ˜¯å¢é‡æ›´æ–°ï¼Œåˆå¹¶æ–°æ•°æ®åˆ°ç°æœ‰æ•°æ®
            if (isIncremental) {
                const existingNodeIds = new Set(currentGraphData.nodes.map(n => n.id));
                const existingLinkIds = new Set(currentGraphData.links.map(l => `${l.source.id || l.source}-${l.target.id || l.target}`));
                
                let newNodesCount = 0;
                let newLinksCount = 0;
                
                // æ·»åŠ æ–°èŠ‚ç‚¹
                nodes.forEach(node => {
                    const nodeId = typeof node === 'string' ? node : (node.id || node.name);
                    if (!existingNodeIds.has(nodeId)) {
                        currentGraphData.nodes.push(node);
                        existingNodeIds.add(nodeId);
                        newNodesCount++;
                    } else if (node.sampled) {
                        // æ›´æ–°ç°æœ‰èŠ‚ç‚¹çš„é‡‡æ ·çŠ¶æ€
                        const existingNode = currentGraphData.nodes.find(n => n.id === nodeId);
                        if (existingNode) {
                            existingNode.sampled = true;
                        }
                    }
                });
                
                // æ·»åŠ æ–°è¿çº¿
                links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id || link.source.name : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id || link.target.name : link.target;
                    const linkId = `${sourceId}-${targetId}`;
                    
                    if (!existingLinkIds.has(linkId)) {
                        currentGraphData.links.push(link);
                        existingLinkIds.add(linkId);
                        newLinksCount++;
                    } else if (link.sampled) {
                        // æ›´æ–°ç°æœ‰è¿çº¿çš„é‡‡æ ·çŠ¶æ€
                        const existingLink = currentGraphData.links.find(l => 
                            `${l.source.id || l.source}-${l.target.id || l.target}` === linkId
                        );
                        if (existingLink) {
                            existingLink.sampled = true;
                        }
                    }
                });
                
                console.log('å¢é‡æ›´æ–°åçš„æ•°æ®:', {
                    totalNodes: currentGraphData.nodes.length,
                    totalLinks: currentGraphData.links.length,
                    newNodes: newNodesCount,
                    newLinks: newLinksCount,
                    sampledNodes: nodes.filter(n => n.sampled).length,
                    sampledLinks: links.filter(l => l.sampled).length
                });
            } else {
                // å®Œå…¨æ›¿æ¢æ•°æ®
                currentGraphData = {nodes: [...nodes], links: [...links]};
                console.log('å®Œå…¨æ›¿æ¢æ•°æ®:', {nodes: nodes.length, links: links.length});
            }
            
            // æ¸²æŸ“æ›´æ–°åçš„å›¾
            renderGraph(currentGraphData, isIncremental);
        }
        
        // æ¸²æŸ“å›¾è¡¨
        function renderGraph(data, isIncremental = true) {
            const nodes = data.nodes || [];
            const links = data.links || [];
            
            // æ•°æ®é¢„å¤„ç† - ç¡®ä¿èŠ‚ç‚¹æ˜¯å¯¹è±¡å¹¶è®¾ç½®åˆå§‹ä½ç½®
            const processedNodes = nodes.map((node, index) => {
                // ç¡®ä¿èŠ‚ç‚¹æ˜¯å¯¹è±¡æ ¼å¼
                let nodeId, nodeName, nodeType;
                if (typeof node === 'string') {
                    nodeId = node;
                    nodeName = node;
                    nodeType = 'default';
                } else {
                    nodeId = node.id || node.name || `node_${index}`;
                    nodeName = node.name || node.id || `Node ${index + 1}`;
                    nodeType = node.type || 'default';
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºé‡‡æ ·èŠ‚ç‚¹ï¼ˆæ˜Ÿåº§å›¾ï¼‰
                const isSampled = node.sampled === true || node.highlighted === true;
                
                // å¦‚æœå·²æœ‰æœ‰æ•ˆä½ç½®ï¼Œä¿æŒä¸å˜
                if (typeof node === 'object' && node.x && node.y && !isNaN(node.x) && !isNaN(node.y)) {
                    return {
                        id: nodeId,
                        name: nodeName,
                        type: nodeType,
                        x: node.x,
                        y: node.y,
                        sampled: isSampled,
                        ...node
                    };
                }
                
                // ä½¿ç”¨ç»Ÿä¸€çš„ä½ç½®åˆ†é…å‡½æ•°
                const positionedNode = createPositionedNode(nodeId, nodeName, nodeType, index, nodes.length);
                positionedNode.sampled = isSampled;
                return positionedNode;
            });
            
            // åˆ›å»ºèŠ‚ç‚¹IDæ˜ å°„ï¼Œç”¨äºå¿«é€ŸæŸ¥æ‰¾
            const nodeIdSet = new Set(processedNodes.map(node => node.id));
            
            // å¤„ç†è¿æ¥æ•°æ® - ç¡®ä¿sourceå’Œtargetå¼•ç”¨æ­£ç¡®çš„èŠ‚ç‚¹ID
            const processedLinks = [];
            links.forEach(link => {
                // ç¡®ä¿è¿æ¥å¯¹è±¡æ ¼å¼æ­£ç¡®
                if (typeof link === 'object' && link.source && link.target) {
                    const sourceId = typeof link.source === 'object' ? link.source.id || link.source.name : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id || link.target.name : link.target;
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºé‡‡æ ·è¿çº¿ï¼ˆæ˜Ÿåº§å›¾ï¼‰
                    const isSampled = link.sampled === true || link.highlighted === true;
                    
                                         // æ£€æŸ¥æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
                    if (!nodeIdSet.has(sourceId)) {
                        console.warn(`Source node not found: ${sourceId}, adding it to nodes`);
                        const newNodeIndex = processedNodes.length;
                        // ä¼°ç®—æœ€ç»ˆèŠ‚ç‚¹æ€»æ•°ï¼ˆå½“å‰èŠ‚ç‚¹æ•° + æ½œåœ¨ç¼ºå¤±èŠ‚ç‚¹æ•°ï¼‰
                        const estimatedTotal = processedNodes.length + links.length;
                        const newNode = createPositionedNode(sourceId, sourceId, 'unknown', newNodeIndex, estimatedTotal);
                        processedNodes.push(newNode);
                        nodeIdSet.add(sourceId);
                    }
                    
                    if (!nodeIdSet.has(targetId)) {
                        console.warn(`Target node not found: ${targetId}, adding it to nodes`);
                        const newNodeIndex = processedNodes.length;
                        // ä¼°ç®—æœ€ç»ˆèŠ‚ç‚¹æ€»æ•°
                        const estimatedTotal = processedNodes.length + links.length;
                        const newNode = createPositionedNode(targetId, targetId, 'unknown', newNodeIndex, estimatedTotal);
                        processedNodes.push(newNode);
                        nodeIdSet.add(targetId);
                    }
                    
                    processedLinks.push({
                        source: sourceId,
                        target: targetId,
                        relation: link.relation || link.relationship || link.type || 'å…³è”',
                        weight: link.weight || 1,
                        sampled: isSampled
                    });
                } else {
                    console.warn('Invalid link data:', link);
                }
            });
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯å’ŒçŠ¶æ€
            nodesCount.textContent = processedNodes.length;
            edgesCount.textContent = processedLinks.length;
            
            // æ˜¾ç¤ºæœ‰å†…å®¹çŠ¶æ€
            if (processedNodes.length > 0) {
                graphContainer.classList.add('has-content');
            }
            
            // æ•°æ®ç»‘å®šå’Œå¢é‡æ›´æ–°
            // å¤„ç†è¿æ¥çº¿
            const linkSelection = g.selectAll('.link')
                .data(processedLinks, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
                
            // ç§»é™¤æ—§çš„è¿æ¥çº¿
            linkSelection.exit()
                .transition()
                .duration(300)
                .style('opacity', 0)
                .remove();
            
            // æ›´æ–°ç°æœ‰è¿æ¥çº¿
            linkSelection
                .classed('sampled', d => d.sampled)
                .style('stroke', d => d.sampled ? '#3b82f6' : '#94a3b8')
                .style('stroke-width', d => d.sampled ? 3 : 2)
                .style('opacity', d => d.sampled ? 1 : 0.7);
            
            // æ·»åŠ æ–°çš„è¿æ¥çº¿
            const newLinks = linkSelection.enter()
                .append('line')
                .attr('class', 'link')
                .classed('sampled', d => d.sampled)
                .attr('marker-end', 'url(#arrowhead)')
                .style('stroke', d => d.sampled ? '#3b82f6' : '#94a3b8')
                .style('stroke-width', d => d.sampled ? 3 : 2)
                .style('opacity', 0)
                .on('mouseover', function(event, d) {
                    if (this._linkHoverTimeout) clearTimeout(this._linkHoverTimeout);
                    this._linkHoverTimeout = setTimeout(() => {
                        d3.select(this).style('stroke', '#3b82f6').style('stroke-width', 3);
                        showTooltip(event, d.relation || 'unknown', `${d.source.id || d.source} â†’ ${d.target.id || d.target}`, false);
                    }, 100);
                })
                .on('mouseout', function(event, d) {
                    if (this._linkHoverTimeout) clearTimeout(this._linkHoverTimeout);
                    this._linkHoverTimeout = setTimeout(() => {
                        const originalStroke = d.sampled ? '#3b82f6' : '#94a3b8';
                        const originalWidth = d.sampled ? 3 : 2;
                        d3.select(this).style('stroke', originalStroke).style('stroke-width', originalWidth);
                        hideTooltip();
                    }, 150);
                });
            
            // æ–°è¿æ¥çº¿å…¥åœºåŠ¨ç”»
            newLinks.transition()
                .duration(500)
                .style('opacity', d => d.sampled ? 1 : 0.7);
            
            // åˆå¹¶æ–°æ—§è¿æ¥çº¿
            const allLinks = newLinks.merge(linkSelection);
            
            // å¤„ç†èŠ‚ç‚¹
            const nodeSelection = g.selectAll('.node')
                .data(processedNodes, d => d.id);
                
            // ç§»é™¤æ—§èŠ‚ç‚¹
            nodeSelection.exit()
                .transition()
                .duration(300)
                .attr('r', 0)
                .style('opacity', 0)
                .remove();
            
            // æ›´æ–°ç°æœ‰èŠ‚ç‚¹
            nodeSelection
                .classed('sampled', d => d.sampled)
                .style('fill', d => d.sampled ? '#3b82f6' : getNodeColor(d.type || 'default'))
                .style('stroke', d => d.sampled ? '#1d4ed8' : '#ffffff')
                .style('stroke-width', d => d.sampled ? 4 : 2);
            
            // æ·»åŠ æ–°èŠ‚ç‚¹
            const newNodes = nodeSelection.enter()
                .append('circle')
                .attr('class', 'node')
                .classed('sampled', d => d.sampled)
                .attr('r', 0)
                .attr('cx', d => d.x || width / 2)
                .attr('cy', d => d.y || height / 2)
                .style('fill', d => d.sampled ? '#3b82f6' : getNodeColor(d.type || 'default'))
                .style('stroke', d => d.sampled ? '#1d4ed8' : '#ffffff')
                .style('stroke-width', d => d.sampled ? 4 : 2)
                .style('cursor', 'pointer')
                .style('opacity', 0)
                .call(d3.drag()
                    .filter(event => event.button === 0)
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseover', function(event, d) {
                    if (this._hoverTimeout) clearTimeout(this._hoverTimeout);
                    this._hoverTimeout = setTimeout(() => {
                        showTooltip(event, d.name || d.id, d.type + (d.sampled ? ' (æ˜Ÿåº§)' : ''), true);
                        d3.select(this).style('stroke', '#3b82f6').style('stroke-width', '3px');
                    }, 50);
                })
                .on('mouseout', function(event, d) {
                    if (this._hoverTimeout) clearTimeout(this._hoverTimeout);
                    this._hoverTimeout = setTimeout(() => {
                        hideTooltip();
                        const originalStroke = d.sampled ? '#1d4ed8' : '#ffffff';
                        const originalWidth = d.sampled ? 4 : 2;
                        d3.select(this).style('stroke', originalStroke).style('stroke-width', originalWidth + 'px');
                    }, 100);
                })
                .on('click', function(event, d) {
                    highlightConnections(d);
                });
            
            // æ–°èŠ‚ç‚¹å…¥åœºåŠ¨ç”»
            newNodes.transition()
                .duration(500)
                .attr('r', d => Math.max(20, Math.min(30, (d.connections || 1) * 5)))
                .style('opacity', 1);
            
            // åˆå¹¶æ–°æ—§èŠ‚ç‚¹
            const allNodes = newNodes.merge(nodeSelection);
            
            // å¤„ç†èŠ‚ç‚¹æ ‡ç­¾
            const labelSelection = g.selectAll('.node-label')
                .data(processedNodes, d => d.id);
                
            labelSelection.exit()
                .transition()
                .duration(300)
                .style('opacity', 0)
                .remove();
            
            const newLabels = labelSelection.enter()
                .append('text')
                .attr('class', 'node-label')
                .text(d => truncateText(d.name || d.id, 12))
                .attr('dy', 40)
                .style('font-size', '12px')
                .style('opacity', 0)
                .style('fill', d => d.sampled ? '#1d4ed8' : '#374151')
                .style('font-weight', d => d.sampled ? 'bold' : 'normal');
            
            newLabels.transition()
                .duration(500)
                .style('opacity', 1);
            
            const allLabels = newLabels.merge(labelSelection);
            
            // å¤„ç†è¿æ¥çº¿æ ‡ç­¾
            const linkLabelSelection = g.selectAll('.link-label')
                .data(processedLinks, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
                
            linkLabelSelection.exit()
                .transition()
                .duration(300)
                .style('opacity', 0)
                .remove();
            
            const newLinkLabels = linkLabelSelection.enter()
                .append('text')
                .attr('class', 'link-label')
                .text(d => d.relation || d.type || 'å…³è”')
                .style('font-size', '10px')
                .style('opacity', 0)
                .style('fill', d => d.sampled ? '#1d4ed8' : '#6b7280')
                .style('font-weight', d => d.sampled ? 'bold' : 'normal');
            
            newLinkLabels.transition()
                .duration(500)
                .style('opacity', d => d.sampled ? 1 : 0.7);
            
            const allLinkLabels = newLinkLabels.merge(linkLabelSelection);
            
            // æ›´æ–°åŠ›å¯¼å‘å›¾
            simulation.nodes(processedNodes);
            simulation.force('link').links(processedLinks);
            simulation.alpha(isIncremental ? 0.3 : 1).restart();
            
            simulation.on('tick', () => {
                allLinks
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                allNodes
                    .attr('cx', d => d.x = Math.max(40, Math.min(width - 40, d.x)))
                    .attr('cy', d => d.y = Math.max(40, Math.min(height - 40, d.y)));
                
                allLabels
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
                
                allLinkLabels
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);
            });
            
            // å»¶é•¿èŠ‚ç‚¹ç¨³å®šæ—¶é—´ï¼Œç¡®ä¿å……åˆ†åˆ†æ•£
            setTimeout(() => {
                if (g && !g.selectAll('.node').empty()) {
                    if (!isIncremental) {
                        fitToView();
                    }
                }
            }, isIncremental ? 1000 : 3000);
            
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯
            console.log(`å›¾è¡¨${isIncremental ? 'å¢é‡' : 'å®Œå…¨'}æ›´æ–°: ${processedNodes.length} ä¸ªèŠ‚ç‚¹, ${processedLinks.length} ä¸ªå…³ç³»`);
            console.log('å¤„ç†åçš„èŠ‚ç‚¹:', processedNodes.map(n => ({id: n.id, name: n.name, sampled: n.sampled, x: n.x, y: n.y})));
            console.log('å¤„ç†åçš„è¿æ¥:', processedLinks.map(l => ({source: l.source, target: l.target, relation: l.relation, sampled: l.sampled})));
        }
        
        // æ˜¾ç¤ºç©ºçŠ¶æ€
        function showEmptyState() {
            const emptyState = document.createElement('div');
            emptyState.className = 'empty-state';
            emptyState.innerHTML = `
                <div class="empty-state-icon">ğŸ•¸ï¸</div>
                <div>æš‚æ— çŸ¥è¯†å›¾è°±æ•°æ®</div>
                <div style="font-size: 12px; margin-top: 8px; opacity: 0.7;">è¯·å…ˆå¼€å§‹æ„å»ºçŸ¥è¯†å›¾è°±</div>
            `;
            graphContainer.appendChild(emptyState);
        }
        
        // æ¸…ç©ºå›¾è¡¨å¹¶é‡ç½®çŠ¶æ€
        function clearGraph() {
            // åœæ­¢ç°æœ‰çš„ä»¿çœŸ
            if (simulation) {
                simulation.stop();
            }
            
            // é‡ç½®å…¨å±€å˜é‡
            svg = null;
            g = null;
            simulation = null;
            zoom = null;
            
            // é‡ç½®å¢é‡æ›´æ–°çš„æ•°æ®
            currentGraphData = {nodes: [], links: []};
            
            // æ¸…ç©ºå®¹å™¨å¹¶ç§»é™¤å†…å®¹çŠ¶æ€
            graphContainer.innerHTML = '';
            graphContainer.classList.remove('has-content');
            
            // é‡ç½®ç»Ÿè®¡æ•°æ®
            nodesCount.textContent = '0';
            edgesCount.textContent = '0';
        }
        
        // é«˜äº®è¿æ¥
        function highlightConnections(node) {
            // é‡ç½®æ‰€æœ‰æ ·å¼
            g.selectAll('.node').style('opacity', 0.3);
            g.selectAll('.link').style('opacity', 0.1);
            g.selectAll('.node-label').style('opacity', 0.3);
            
            // é«˜äº®é€‰ä¸­èŠ‚ç‚¹
            g.selectAll('.node').filter(d => d.id === node.id).style('opacity', 1);
            g.selectAll('.node-label').filter(d => d.id === node.id).style('opacity', 1);
            
            // é«˜äº®ç›¸å…³è¿æ¥å’ŒèŠ‚ç‚¹
            g.selectAll('.link').filter(d => d.source.id === node.id || d.target.id === node.id)
                .style('opacity', 1)
                .style('stroke', '#3b82f6')
                .style('stroke-width', 3);
            
            g.selectAll('.node').filter(d => 
                g.selectAll('.link').data().some(link => 
                    (link.source.id === node.id && link.target.id === d.id) ||
                    (link.target.id === node.id && link.source.id === d.id)
                )
            ).style('opacity', 1);
            
            g.selectAll('.node-label').filter(d => 
                g.selectAll('.link').data().some(link => 
                    (link.source.id === node.id && link.target.id === d.id) ||
                    (link.target.id === node.id && link.source.id === d.id)
                )
            ).style('opacity', 1);
            
            // 3ç§’åæ¢å¤
            setTimeout(() => {
                g.selectAll('.node').style('opacity', 1);
                g.selectAll('.link').style('opacity', 0.7).style('stroke', '#94a3b8').style('stroke-width', 2);
                g.selectAll('.node-label').style('opacity', 1);
            }, 3000);
        }
        
        // æˆªæ–­æ–‡æœ¬
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }
        
        // ç¼©æ”¾æ§åˆ¶å‡½æ•°
        function zoomIn() {
            svg.transition().duration(300).call(zoom.scaleBy, 1.5);
        }
        
        function zoomOut() {
            svg.transition().duration(300).call(zoom.scaleBy, 1 / 1.5);
        }
        
        function resetZoom() {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        }
        
        function fitToView() {
            if (!g || !svg || g.selectAll('.node').empty()) return;
            
            const nodes = g.selectAll('.node').data();
            if (nodes.length === 0) return;
            
            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);
            
            // ç¡®ä¿æœ‰æœ‰æ•ˆçš„èŒƒå›´
            if (!xExtent[0] || !xExtent[1] || !yExtent[0] || !yExtent[1]) return;
            
            const padding = 100;
            const graphWidth = Math.max(xExtent[1] - xExtent[0], 200) + padding * 2;
            const graphHeight = Math.max(yExtent[1] - yExtent[0], 200) + padding * 2;
            
            const scale = Math.min(width / graphWidth, height / graphHeight, 1.5);
            const centerX = width / 2 - (xExtent[0] + xExtent[1]) / 2 * scale;
            const centerY = height / 2 - (yExtent[0] + yExtent[1]) / 2 * scale;
            
            svg.transition().duration(1000).call(
                zoom.transform,
                d3.zoomIdentity.translate(centerX, centerY).scale(scale)
            );
        }
        
        // é‡æ–°åˆ†å¸ƒèŠ‚ç‚¹
        function redistributeNodes() {
            if (!g || !simulation || g.selectAll('.node').empty()) return;
            
            const nodes = g.selectAll('.node').data();
            if (nodes.length === 0) return;
            
            // é‡æ–°åˆ†é…èŠ‚ç‚¹ä½ç½®
            nodes.forEach((node, index) => {
                // ç¡®ä¿èŠ‚ç‚¹æ˜¯å¯¹è±¡
                if (typeof node === 'string') {
                    console.error('èŠ‚ç‚¹æ•°æ®ä¸åº”è¯¥æ˜¯å­—ç¬¦ä¸²:', node);
                    return;
                }
                
                const nodeCount = nodes.length;
                const centerX = width / 2;
                const centerY = height / 2;
                
                let x, y;
                if (nodeCount <= 1) {
                    x = centerX;
                    y = centerY;
                } else if (nodeCount <= 6) {
                    // å°‘é‡èŠ‚ç‚¹æ—¶ä½¿ç”¨åœ†å½¢åˆ†å¸ƒ
                    const angle = (index / nodeCount) * 2 * Math.PI;
                    const radius = Math.min(width, height) * 0.25;
                    x = centerX + Math.cos(angle) * radius;
                    y = centerY + Math.sin(angle) * radius;
                } else {
                    // å¤šèŠ‚ç‚¹æ—¶ä½¿ç”¨ç½‘æ ¼+éšæœºåˆ†å¸ƒ
                    const cols = Math.ceil(Math.sqrt(nodeCount));
                    const rows = Math.ceil(nodeCount / cols);
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    
                    const spacingX = (width * 0.8) / Math.max(cols - 1, 1);
                    const spacingY = (height * 0.8) / Math.max(rows - 1, 1);
                    
                    x = (width * 0.1) + col * spacingX + (Math.random() - 0.5) * 60;
                    y = (height * 0.1) + row * spacingY + (Math.random() - 0.5) * 60;
                }
                
                // æ›´æ–°èŠ‚ç‚¹ä½ç½®
                node.x = Math.max(60, Math.min(width - 60, x));
                node.y = Math.max(60, Math.min(height - 60, y));
                node.fx = null; // æ¸…é™¤å›ºå®šä½ç½®
                node.fy = null;
            });
            
            // é‡å¯ä»¿çœŸ
            simulation.alpha(1).restart();
            
            console.log('èŠ‚ç‚¹å·²é‡æ–°åˆ†å¸ƒ');
        }
        
        // æµ‹è¯•å›¾è¡¨åŠŸèƒ½
        function testGraph() {
            const testData = {
                nodes: [
                    {id: 'node1', name: 'èŠ‚ç‚¹1', type: 'concept'},
                    {id: 'node2', name: 'èŠ‚ç‚¹2', type: 'person'},
                    {id: 'node3', name: 'èŠ‚ç‚¹3', type: 'organization'},
                    {id: 'node4', name: 'èŠ‚ç‚¹4', type: 'location'},
                    {id: 'node5', name: 'èŠ‚ç‚¹5', type: 'technology'}
                ],
                links: [
                    {source: 'node1', target: 'node2', relation: 'å…³è”'},
                    {source: 'node2', target: 'node3', relation: 'å±äº'},
                    {source: 'node3', target: 'node4', relation: 'ä½äº'},
                    {source: 'node4', target: 'node5', relation: 'ä½¿ç”¨'},
                    {source: 'node5', target: 'node1', relation: 'åº”ç”¨'}
                ]
            };
            
            console.log('å¼€å§‹æµ‹è¯•å›¾è¡¨...');
            updateGraph(testData);
        }
        
        // è·å–èŠ‚ç‚¹é¢œè‰²
        function getNodeColor(type) {
            const colors = {
                'person': '#ef4444',
                'organization': '#3b82f6',
                'location': '#10b981',
                'concept': '#f59e0b',
                'technology': '#8b5cf6',
                'event': '#ec4899',
                'entity': '#6b7280',
                'default': '#6b7280'
            };
            return colors[type] || colors['default'];
        }
        
        // æ‹–æ‹½äº‹ä»¶å¤„ç†
        function dragstarted(event, d) {
            // åªæœ‰åœ¨çœŸæ­£å¼€å§‹æ‹–æ‹½æ—¶æ‰æ¿€æ´»ï¼ˆé¼ æ ‡æŒ‰ä¸‹åç§»åŠ¨ï¼‰
            if (!event.active) simulation.alphaTarget(0.3).restart();
            
            // å›ºå®šèŠ‚ç‚¹ä½ç½®
            d.fx = d.x;
            d.fy = d.y;
            
            // éšè—tooltip
            hideTooltip();
            
            // æ”¹å˜å…‰æ ‡æ ·å¼
            d3.select(this).style('cursor', 'grabbing');
            
            // é«˜äº®æ­£åœ¨æ‹–æ‹½çš„èŠ‚ç‚¹
            d3.select(this).style('stroke', '#ef4444').style('stroke-width', '4px');
        }
        
        function dragged(event, d) {
            // æ›´æ–°èŠ‚ç‚¹ä½ç½®
            d.fx = event.x;
            d.fy = event.y;
            
            // æ‰‹åŠ¨æ›´æ–°èŠ‚ç‚¹ä½ç½®ï¼Œç¡®ä¿è¿çº¿è·Ÿéš
            d.x = event.x;
            d.y = event.y;
            
            // ç«‹å³æ›´æ–°è¿çº¿ä½ç½®
            g.selectAll('.link')
                .filter(link => link.source === d || link.target === d)
                .attr('x1', link => link.source.x)
                .attr('y1', link => link.source.y)
                .attr('x2', link => link.target.x)
                .attr('y2', link => link.target.y);
                
            // ç«‹å³æ›´æ–°èŠ‚ç‚¹æ ‡ç­¾ä½ç½®
            g.selectAll('.node-label')
                .filter(node => node === d)
                .attr('x', d.x)
                .attr('y', d.y);
                
            // ç«‹å³æ›´æ–°è¿çº¿æ ‡ç­¾ä½ç½®
            g.selectAll('.link-label')
                .filter(link => link.source === d || link.target === d)
                .attr('x', link => (link.source.x + link.target.x) / 2)
                .attr('y', link => (link.source.y + link.target.y) / 2);
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            
            // é‡Šæ”¾èŠ‚ç‚¹ä½ç½®å›ºå®š
            d.fx = null;
            d.fy = null;
            
            // æ¢å¤å…‰æ ‡æ ·å¼
            d3.select(this).style('cursor', 'pointer');
            
            // æ¢å¤æ­£å¸¸è¾¹æ¡†
            d3.select(this).style('stroke', 'none').style('stroke-width', '0px');
            
            // é‡æ–°å¯åŠ¨ä»¿çœŸä»¥ç¨³å®šä½ç½®
            simulation.alpha(0.1).restart();
        }
        
        // Tooltip åŠŸèƒ½
        let tooltipTimeout;
        function showTooltip(event, title, subtitle, isFixed = false) {
            clearTimeout(tooltipTimeout);
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `<strong>${title}</strong><br/><small>${subtitle || ''}</small>`;
            
            if (isFixed) {
                // å›ºå®šåœ¨èŠ‚ç‚¹é™„è¿‘ï¼Œä¸è·Ÿéšé¼ æ ‡
                const nodeElement = event.target;
                const rect = nodeElement.getBoundingClientRect();
                const containerRect = document.getElementById('graph-container').getBoundingClientRect();
                
                // è®¡ç®—tooltipçš„ä½ç½®ï¼Œç¡®ä¿ä¸ä¼šè¶…å‡ºå®¹å™¨è¾¹ç•Œ
                let left = rect.left - containerRect.left + rect.width + 10;
                let top = rect.top - containerRect.top - 10;
                
                // è¾¹ç•Œæ£€æŸ¥
                if (left + 200 > containerRect.width) { // 200æ˜¯tooltipçš„å¤§æ¦‚å®½åº¦
                    left = rect.left - containerRect.left - 210; // æ˜¾ç¤ºåœ¨èŠ‚ç‚¹å·¦è¾¹
                }
                if (top < 0) {
                    top = rect.top - containerRect.top + rect.height + 10; // æ˜¾ç¤ºåœ¨èŠ‚ç‚¹ä¸‹æ–¹
                }
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            } else {
                // è·Ÿéšé¼ æ ‡ï¼ˆç”¨äºè¿çº¿ç­‰ï¼‰
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            }
            
            tooltip.classList.add('show');
        }
        
        function hideTooltip() {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = setTimeout(() => {
                document.getElementById('tooltip').classList.remove('show');
            }, 150);
        }
        
        // æ·»åŠ æ—¥å¿—
        function addLog(level, message, timestamp = null) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${level.toLowerCase()}`;
            
            const time = timestamp || new Date().toLocaleTimeString();
            logEntry.innerHTML = `
                <span class="timestamp">${time}</span>
                <span class="level">${level}</span>
                <span class="message">${message}</span>
            `;
            
            logsContainer.appendChild(logEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
            
            // é™åˆ¶æ—¥å¿—æ•°é‡
            while (logsContainer.children.length > 100) {
                logsContainer.removeChild(logsContainer.firstChild);
            }
        }
        
        // å¼€å§‹æ„å»º
        startBtn.addEventListener('click', () => {
            if (isBuilding) return;
            
            const entity = initialEntity.value.trim();
            if (!entity) {
                alert('è¯·è¾“å…¥åˆå§‹å®ä½“');
                return;
            }
            
            isBuilding = true;
            startBtn.disabled = true;
            stopBtn.style.display = 'inline-flex';
            progressInfo.style.display = 'block';
            
            btnText.innerHTML = '<span class="loading-spinner"></span> æ„å»ºä¸­...';
            
            // æ¸…ç©ºå›¾è¡¨å¹¶é‡ç½®çŠ¶æ€
            clearGraph();
            
            // éšè—QAç»“æœ
            const qaContainer = document.getElementById('qa-result-container');
            if (qaContainer) qaContainer.style.display = 'none';
            
            // æ¸…ç©ºæ—¥å¿—
            logsContainer.innerHTML = '';
            addLog('INFO', `å¼€å§‹æ„å»ºçŸ¥è¯†å›¾è°±ï¼Œåˆå§‹å®ä½“ï¼š${entity}`);
            
            // å‘é€æ„å»ºè¯·æ±‚
            fetch('/api/start_building', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    entity: entity,
                    max_nodes: parseInt(maxNodes.value),
                    sample_size: parseInt(sampleSize.value)
                })
            }).then(response => response.json())
              .then(data => {
                  if (data.error) {
                      addLog('ERROR', data.error);
                      resetUI();
                  } else {
                      addLog('SUCCESS', data.message);
                  }
              }).catch(error => {
                  addLog('ERROR', 'è¯·æ±‚å¤±è´¥ï¼š' + error.message);
                  resetUI();
              });
        });
        
        // åœæ­¢æ„å»º
        stopBtn.addEventListener('click', () => {
            fetch('/api/stop_building', {
                method: 'POST'
            }).then(response => response.json())
              .then(data => {
                  addLog('INFO', data.message);
                  resetUI();
              });
        });
        
        // é‡ç½®UI
        function resetUI() {
            isBuilding = false;
            startBtn.disabled = false;
            stopBtn.style.display = 'none';
            btnText.textContent = 'å¼€å§‹æ„å»º';
            progressFill.style.width = '0%';
            statusText.textContent = 'å·²åœæ­¢';
        }
        
        // Socket.IO äº‹ä»¶ç›‘å¬
        socket.on('connect', () => {
            addLog('SUCCESS', 'å·²è¿æ¥åˆ°æœåŠ¡å™¨');
        });
        
        socket.on('disconnect', () => {
            addLog('ERROR', 'ä¸æœåŠ¡å™¨è¿æ¥æ–­å¼€');
            resetUI();
        });
        
        socket.on('progress_update', (data) => {
            progressFill.style.width = data.progress + '%';
            statusText.textContent = data.step;
            addLog('INFO', `${data.step} (${data.progress}%)`);
        });
        
        socket.on('graph_update', (data) => {
            updateGraph(data, true); // å¢é‡æ›´æ–°
            addLog('INFO', `å›¾è°±å¢é‡æ›´æ–°ï¼š${data.nodes.length} ä¸ªèŠ‚ç‚¹ï¼Œ${data.links.length} ä¸ªå…³ç³»`);
        });
        
        socket.on('sampled_graph_update', (data) => {
            // æ ‡è®°é‡‡æ ·çš„èŠ‚ç‚¹å’Œè¿çº¿
            const sampledNodes = data.nodes.map(node => ({...node, sampled: true}));
            const sampledLinks = data.links.map(link => ({...link, sampled: true}));
            
            updateGraph({nodes: sampledNodes, links: sampledLinks}, true);
            addLog('INFO', `æ˜Ÿåº§å›¾é«˜äº®ï¼š${data.nodes.length} ä¸ªèŠ‚ç‚¹ï¼Œ${data.links.length} ä¸ªå…³ç³»`);
        });
        
        socket.on('building_complete', (data) => {
            if (data.success) {
                addLog('SUCCESS', data.message);
                progressFill.style.width = '100%';
                statusText.textContent = 'æ„å»ºå®Œæˆ';
                
                // æ˜¾ç¤ºQAç»“æœ
                if (data.qa_result && Object.keys(data.qa_result).length > 0) {
                    showQAResult(data.qa_result);
                }
            } else {
                addLog('ERROR', data.message || data.error);
            }
            resetUI();
        });
        
        // æ˜¾ç¤ºQAç»“æœ
        function showQAResult(qaResult) {
            const qaContainer = document.getElementById('qa-result-container');
            const qaQuestionText = document.getElementById('qa-question-text');
            const qaAnswerText = document.getElementById('qa-answer-text');
            const qaType = document.getElementById('qa-type');
            const qaComplexity = document.getElementById('qa-complexity');
            const qaReasoning = document.getElementById('qa-reasoning');
            const qaReasoningText = document.getElementById('qa-reasoning-text');
            
            // è®¾ç½®å†…å®¹
            qaQuestionText.textContent = qaResult.question || 'æš‚æ— é—®é¢˜';
            qaAnswerText.textContent = qaResult.answer || 'æš‚æ— ç­”æ¡ˆ';
            qaType.textContent = qaResult.question_type || 'æœªçŸ¥';
            qaComplexity.textContent = qaResult.complexity || 'æœªçŸ¥';
            
            // å¤„ç†æ¨ç†è¿‡ç¨‹
            if (qaResult.reasoning) {
                qaReasoningText.textContent = qaResult.reasoning;
                qaReasoning.style.display = 'block';
            } else {
                qaReasoning.style.display = 'none';
            }
            
            // æ˜¾ç¤ºQAå®¹å™¨
            qaContainer.style.display = 'block';
            
            // æ·»åŠ åˆ°æ—¥å¿—
            addLog('SUCCESS', 'å·²ç”ŸæˆQAé—®ç­”å¯¹');
        }
        
        // QAç»“æœæŠ˜å /å±•å¼€åŠŸèƒ½
        document.addEventListener('DOMContentLoaded', function() {
            const toggleQABtn = document.getElementById('toggle-qa-btn');
            const qaResultContent = document.getElementById('qa-result-content');
            
            if (toggleQABtn) {
                toggleQABtn.addEventListener('click', function() {
                    if (qaResultContent.classList.contains('collapsed')) {
                        qaResultContent.classList.remove('collapsed');
                        toggleQABtn.textContent = 'æŠ˜å ';
                    } else {
                        qaResultContent.classList.add('collapsed');
                        toggleQABtn.textContent = 'å±•å¼€';
                    }
                });
            }
        });
        
        // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°åˆå§‹åŒ–å›¾è¡¨
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (svg && simulation) {
                    const containerRect = graphContainer.getBoundingClientRect();
                    const newWidth = containerRect.width;
                    const newHeight = containerRect.height;
                    
                    if (newWidth !== width || newHeight !== height) {
                        width = newWidth;
                        height = newHeight;
                        
                        // æ›´æ–°SVGå°ºå¯¸
                        svg.attr('width', width).attr('height', height);
                        
                        // æ›´æ–°åŠ›å¯¼å‘å›¾ä¸­å¿ƒ
                        simulation.force('center', d3.forceCenter(width / 2, height / 2));
                        simulation.force('x', d3.forceX(width / 2));
                        simulation.force('y', d3.forceY(height / 2));
                        simulation.alpha(0.3).restart();
                    }
                }
            }, 250);
        });
    </script>
</body>
</html>